#!/usr/bin/env ruby
require 'rubygems'
require 'plist'
require 'pathname'
require 'fileutils'
require 'pp'
require 'streamio-ffmpeg'

class EyeTVScanTask
  #EYETV_FOLDER = "/media/Video/EyeTV"
  EYETV_FOLDER = "/Users/thomas/test"
  #PLEX_FOLDER  = "/media/Video/Recordings"
  PLEX_FOLDER  = "/Users/thomas/recordings"
  # minAge = 5 days, limit recordings to stuff older than this (in seconds)
  MINAGE = 5*24*60*60

  def run
    recordings.select(&:done?).each do |recording|
      dest = recording.destination(Pathname.new(PLEX_FOLDER)) 
      recordingAge = Time.now() - recording.media_file.mtime
      # if destination doesn't exist and our recording is older than MINAGE seconds, then copy files
      unless File.exists?(dest) or recordingAge<MINAGE then
        movie = FFMPEG::Movie.new(recording.media_file)
        FileUtils.mkdir_p dest.dirname
        File.chmod(0777, dest.dirname)
        xmlsource=recording.locate('.eyetvr')
        xmlfile=Pathname.new(dest.to_s.sub(/\.mpg$/,'.eyetvr'))

        FileUtils.copy(xmlsource,xmlfile)

        # Do a transcode - copy of mpg file, avoids some invalid mpgs generated by EyeTV
        # add:  { |progress| puts progress } if progress is needed
        movie.transcode(dest, '-c copy')

        # Dealing with summary/description
        sumfile=Pathname.new(dest.to_s.sub(/\.mpg$/,'.summary'))
        summaryFile=File.open(sumfile,'w')
        summaryFile.write(recording.description)
        summaryFile.close()
        
        #File.chmod(0666,dest)  
        #File.chmod(0666,xmlfile)
        File.chmod(0666,summaryFile)
        puts "written file #{sumfile}"
        if File.directory? recording.media_file.dirname then
          puts "Remove directory: #{recording.media_file.dirname}"
          FileUtils.rm_rf(recording.media_file.dirname)
        end
      end
    end
  end

  def children_with(path, ext)
    path.children.select {|n| n.basename.to_s.end_with?(ext) }
  end

  def recordings
    children_with(Pathname.new(EYETV_FOLDER), '.eyetv').
      reject {|d| d == "Live TV Buffer.eyetv" }.
      map {|dir| recordings_in(dir) }.flatten
  end

  def recordings_in(dir)
    children_with(dir, '.mpg').map {|file| Recording.new(file) }
  end
end

class Recording
  attr_accessor :media_file

  def initialize(file)
    @media_file = Pathname.new(file)
  end

  def locate(ext)
    Pathname.new(@media_file.to_s.sub(/\.mpg$/, ext))
  end

  def done?
    !media_file.basename.to_s.start_with?("busy_")
  end

  def metadata
    @plist ||= Plist::parse_xml(locate('.eyetvr'))
  end

  def title
    metadata['info']['recording title'].gsub(/\[.*?\]/, '')
  end

  def subtitle
    metadata['info']['episode title'] || ''
  end

  def description
    metadata['info']['description'] || ''
  end

  def date
    metadata['info']['start']
  end

  def year
    date.year
  end

  def destination(base, alternate = false)
    base.join(title, year.to_s, plex_filename(alternate))
  end

  def escape(string)
    string.gsub(/\//, ':')
  end

  def plex_filename(alternate = false)
    name = "#{escape(title)} - #{date.strftime('%Y-%m-%d')}"
    if alternate
      name << " - #{media_file.basename.sub(/.mpg$/, '')}"
    elsif !subtitle.empty?
      name << " - #{escape(subtitle)}"
    end
    name << media_file.extname
  end
end

EyeTVScanTask.new.run